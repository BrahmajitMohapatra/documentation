# RSA累加器的介绍

## 一、RSA累加器的介绍
一个密码学上的累加器是一个单向的隶属函数。它可用于识别一个候选是否为一个集合的成员，且不会在过程中暴露集合中的成员。这是WIKI上的定义。
</br>
目前在主流的区块链中，用来对交易进行验证的是通过默克尔树传递数据来进行的，特别是轻量级节点和钱包，基本是离不开默克尔树的数据交换的。如果在比特币网络中，还稍好一些，毕竟比特币的交易速度有限。但随着以太坊及EOS的出现，交易量开始不断上升，那么，做为需要进行网络通信的默克尔树的数据，就开始变得越来越大。
</br>
所网上资料讲，V神估计以目前的Plasma子链数据交易状况，默克尔树的数据大小应该在2.5G左右，这不是一个小的数据，它使得存储和数据交换的压力会越来越大。同时，V神提出如果使用RSA ACCumulactors累加器的方式来替代默克树的话，可以将上述的数据降低到大约大3.6M左右，这是一个非常大的提高。
累加器：“一个密码学累加器，其会产生对一组元素的短期约束承诺，以及对集合中任何元素的短期成员身份和非成员身份证明。”
</br>
动态累加器：“支持添加和删除具有O(1) 成本的元素累加器，其与累积元素数量无关。”
</br>
通用累加器：“支持成员和非成员身份证明的动态累加器。”
</br>
批处理：批验证n个证明，要比验证单个证明要快n倍。
</br>
聚合：在一个常量大小的证明中聚合n个成员证明。
</br>
未知顺序组：组的顺序是其集合中元素的数目。为了保证所提供的证明的安全性，需要生成一组未知顺序（否则累加器中使用的模数有已知的因子分解，并且可以创建伪证明）。生成它可通过多方计算完成，但如果生成方串通检索生成的数的阶乘，则这是不安全的。它可通过使用类组在没有可信设置的情况下生成（注：这点是非常重要的）

## 二、累加器涉及到的知识

1、双线性映射和双线性函数
也即双线性配对，一个双线性映射是由两个向量空间上的元素，生成第三个向量空间上一个元素之函数，并且该函数对每个参数都是线性的。线性的意思就是可加与成比例。
RAS累加器和双线性累加器都是密码学中的方法。累加器多用于环签名中。双线性映射就会引出双线性函数，举一个例子，二次型就是一个对称的双线性函数。双线性映射有三个特点：双线性性，非退化性和可计算性。
</br>
2、离散对数
在整数中，离散对数（英语：Discrete logarithm）是一种基于同余运算和原根的一种对数运算。而在实数中对数的定义 logba是指对于给定的a和b，有一个数x，使得bx=a。相同地在任何群G中可为所有整数k定义一个幂数为bx，而离散对数logba是指使得bx=a的整数k。
</br>
3、互质
又称为互素，在数论中，如果两个或两个以上的整数的最大公约数为1，则称他们为互质。
</br>
4、奇质数
质数（Prime number），又称素数，指在大于1的自然数中，除了1和该数自身外，无法被其他自然数整除的数（也可定义为只有1与该数本身两个正因数的数）。大于1的自然数若不是素数，则称之为合数（也称为合成数）。奇质数，系指任何大于2的素数。
</br>
搞加密对数学的要求还是有一些的，比较头痛。


## 三、整体的流程
这里把基本的流程过一下，实际的算法可能会比这个复杂不少，但原理是这样的：
## 1、给定一个模数N和一个发生器G（代表空的累加器），对于集合{u}和增加到累加器集合的U，设定累加器C，（C,N都很大），则有：
C = G ^ U％N

## 2、从{u}中获取值的子集{r}。为了计算证明，上需要{u}的所有其他值，将那些秘密值标记为{s}。即有R * S = U.证明P是：
P = G^S % N

## 3、向证明方提供{r}和P. 计算C'并验证它等于C：
C'= P ^ R％N
## 4、通过替换P，可以看到C'必须等于C：
C'= G ^ S ^ R = G ^（S * R）= G ^ U = C％N

上面的说法比较抽象，举一个简单的例子：
假设要把3，5，11这几个值增加到累加器c中，那么C=G^165,为证明3是累加器的一部分，可以使用(G^3)^x=C来证明它。在这种情况下x=55，在实际的应用中，肯定不能这么简单，一般来说会把指数做得非常大。这就需要上面的代数式来进行推算证明。
</br>
为了安全起见，可以在{u}中添加一个很大质数，这在加密算法里叫做加盐。
上面是证明成员身份的过程，而证明非成员的过程比较复杂，这里推荐大家看一下相关的文章，V神也提出了自己的证明方法，在后面分析到相关的部分时，再进行具体的说明。

## 四、总结
这里仅仅是简单的对RSA ACC进行了一个简单的介绍，重点是明白累加器到底是什么。累加器在加密领域的应用从1994年开始，在区块链中的应用，没有多长时间，累加器的优点在上面提到了，缺点也很明显，目前来看，累加器的验证集合是不断的动态变化的，导致证明的过程有些复杂，网上有相关的例子，可以从GITHUB上下来运行一下，随着数据的增长，还是相当慢的，距离实用仍然还要走一大段路。
